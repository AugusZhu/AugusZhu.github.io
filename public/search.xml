<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Tomcat调优]]></title>
    <url>%2F2019%2F12%2F09%2FTomcat%E8%B0%83%E4%BC%98%2F</url>
    <content type="text"><![CDATA[Tomcat运行模式 分3种模式: bio,nio,apr 一般使用nio模式bio效率低,apr对系统配置有一些比较高的要求 确认Tomcat的运行模式 配置文件 server.xml 1&lt;Executor name="tomcatThreadPool" namePrefix="catalina-exec-" maxThreads="1024" minSpareThreads="512" prestartminSpareThreads="true" /&gt; 关键配置 maxThreads 最大线程数, 默认是200 minSpareThread 最小活跃线程数, 默认是25 maxQueueSize 最大的等待队列个数，超过则请求拒绝默认值是Integer.MAX_VALUE ，一般不改变。在某些紧急状态修复问题需要调整 连接器（Connector）优化Connector是连接器，负责接收客户的请求，以及向客户端回送响应的消息。所以Connector的优化是重要部分。默认情况下 Tomcat只支持200线程访问，超过这个数量的连接将被等待甚至超时放弃，所以我们需要提高这方面的处理能力。 nio配置- server.xml 1&lt;Connector port="14081" protocol="org.apache.coyote.http11.Http11NioProtocol"connectionTimeout="20000"executor="tomcatThreadPool" URIEncoding="UTF-8" compression="on" useBodyEncodingForURI="true" enableLookups="false" redirectPort="14443" /&gt; 影响性能配置 protocol 1234org.apache.coyote.http11.Http11Protocol - 阻塞式的Java连接器org.apache.coyote.http11.Http11NioProtocol - 不阻塞Java连接器org.apache.coyote.http11.Http11AprProtocol - APR / native 连接器选择不阻塞java连接 enableLookups 1若是你想request.getRemoteHost()的调用履行，以便返回的长途客户端的实际主机名的DNS查询，则设置为true。设置为false时跳过DNS查找，并返回字符串的IP地址（从而提高性能）。默认场景下，禁用DNS查找 compression 1设置成on,开启压缩 禁用AJP链接器 123使用Nginx+tomcat的架构，用不着AJP协议，所以把AJP连接器禁用server.xml注释掉以下配置&lt;Connector port="8019" protocol="AJP/1.3" redirectPort="8443" /&gt; 优化JVM修改JAVA_OPTS参数 JDK1.7 1JAVA_OPTS="-Djava.awt.headless=true -Dfile.encoding=UTF-8 -server -Xms512m -Xmx1024m -XX:NewSize=512m -XX:MaxNewSize=1024M -XX:PermSize=1024m -XX:MaxPermSize=1024m -XX:+DisableExplicitGC" JDK1.8 1JAVA_OPTS="-Djava.awt.headless=true -Dfile.encoding=UTF-8 -server -Xms1024m -Xmx1024m -XX:NewSize=512m -XX:MaxNewSize=1024M -XX:+DisableExplicitGC" 1.8 版本中已经没有PermSize、MaxPermSize JAVA8里对metaspace可以在小范围自动扩展永生代避免溢出。 参数说明 -Djava.awt.headless 1没有设备、键盘或鼠标的模式。 -Dfile.encoding 1设置字符集 -server 1vm的server工作模式，对应的有client工作模式。使用“java -version”可以查看当前工作模式 -Xms1024m 1初始Heap大小，使用的最小内存 -Xmx1024m 12Java heap最大值，使用的最大内存经验: 设置Xms大小等于Xmx大小 -XX:NewSize=512m 1表示新生代初始内存的大小，应该小于 -Xms的值 -XX:MaxNewSize=1024M 1表示新生代可被分配的内存的最大上限，应该小于 -Xmx的值 -XX:PermSize=1024m 1设定内存的永久保存区域,内存的永久保存区域，VM 存放Class 和 Meta 信息，JVM在运行期间不会清除该区域 程序加载很多class情况下，超出PermSize情况下 JDK1.7会抛出java.lang.OutOfMemoryError: PermGen space异常 JDK1.8下会抛出 ERROR: java.lang.OutOfMemoryError: Metadata space 异常 -XX:MaxPermSize=1024m 12设定最大内存的永久保存区域经验: 设置PermSize大小等于MaxPermSize大小 -XX:+DisableExplicitGC 1自动将System.gc()调用转换成一个空操作，即应用中调用System.gc()会变成一个空操作,避免程序员在代码里进行System.gc()这种危险操作。System.gc() 除非是到了万不得以的情况下不使用，都交给JVM吧 其他优化参数 -XX:SurvivorRatio=2 1年轻代中Eden区与Survivor区的大小比值 -XX:ReservedCodeCacheSize=256m 1保留代码占用的内存容量，无大的影响 -Xss1024k 1单个线程堆栈大小值，减少这个值可以生成更多线程，但操作系统对于一个进程内的线程数是有限制的，经验值在3000-5000左右 -XX:+CMSParallelRemarkEnabled 1CMS 垃圾回收算法，对响应时间的重要性需求 大于 对吞吐量的要求，能够承受垃圾回收线程和应用线程共享处理器资源，并且应用中存在比较多的长生命周期的对象的应用 -XX:+UseCMSCompactAtFullCollection 1在使用concurrent gc 的情况下, 防止 memoryfragmention, 对live object 进行整理, 使 memory 碎片减少。 -XX:+UseCMSInitiatingOccupancyOnly 1在FULL GC的时候， 对年老代的压缩。CMS是不会移动内存的， 因此这个非常容易产生碎片， 导致内存不够用， 因此， 内存的压缩这个时候就会被启用。 增加这个参数是个好习惯。可能会影响性能,但是可以消除碎片。 -XX:CMSInitiatingOccupancyFraction=60 1使用cms作为垃圾回收, 使用60％后开始CMS收集 -XX:+UseGCOverheadLimit 12用来限制使用内存，如果不做控制，可能会报出java.lang.OutOfMemoryError: GC overhead limit exceeded -XX:+UseConcMarkSweepGC 1使用CMS内存收集 -XX:+UseParNewGC 1设置年轻代为并行收集 -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/x/dump_tomcat.hprof 1JVM会在遇到OutOfMemoryError时拍摄一个“堆转储快照”，并将其保存在一个文件中。 -Xloggc:/xx/gc_tomcat.log 1gc的日志，如果该日志中出现频繁的Full GC就是有相关的系统问题，如果很少，说明暂时还算正常 -XX:+PrintGCDateStamps 1输出GC的时间戳（以基准时间的形式） -XX:+PrintGCDetails 1输出GC的日志格式 -Dnetworkaddress.cache.ttl=60 -Dsun.net.inetaddr.ttl=60 1设置DNS缓存时间 -DautoStartup=false -Dsun.net.client.defaultConnectTimeout=60000 1连接建立超时时间 -Dsun.net.client.defaultReadTimeout=60000 1内容获取超时设置 -Djmagick.systemclassloader=no 1是否生成缩略图的一个框架的配置]]></content>
      <categories>
        <category>Tomcat</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[导入安全证书到jdk默认库]]></title>
    <url>%2F2019%2F12%2F09%2F%E5%AF%BC%E5%85%A5%E5%AE%89%E5%85%A8%E8%AF%81%E4%B9%A6%E5%88%B0jdk%E9%BB%98%E8%AE%A4%E5%BA%93%2F</url>
    <content type="text"><![CDATA[把证书上传到数据库服务器 目录切换到oracle的bin目录下执行以下命令： 创建walletorapki wallet create –wallet &quot;F:/cert_file/cert&quot; –pwd PASS1!2@3# -auto_login 添加信任证书orapki wallet add -wallet F:\cert_file\cert -trusted_cert -cert &quot;F:\hls_file\cert\paytest.cer&quot; -pwd PASS1!2@3# 查看wallet里面的证书orapki wallet display -wallet F:\cert_file\cert -pwd PASS1!2@3#]]></content>
      <categories>
        <category>Oracle</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-Java知识点总结]]></title>
    <url>%2F2019%2F12%2F09%2F2019-Java%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[1.ArrayList 和 LinkedList 有什么区别 ArrayList和LinkedList都实现了List接口，有以下的不同点： ArrayList是基于索引的数据接口，它的底层是数组。它可以以O(1)时间复杂度对元素进行随机访问。与此对应，LinkedList是以元素列表的形式存储它的数据，每一个元素都和它的前一个和后一个元素链接在一起，在这种情况下，查找某个元素的时间复杂度是O(n)。 相对于ArrayList，LinkedList的插入，添加，删除操作速度更快，因为当元素被添加到集合任意位置的时候，不需要像数组那样重新计算大小或者是更新索引。 LinkedList比ArrayList更占内存，因为LinkedList为每一个节点存储了两个引用，一个指向前一个元素，一个指向下一个元素 2.类的实例化顺序，比如父类静态数据，构造函数，字段，子类静态数据，构造函数，字段，当 new 的时候， 他们的执行顺序 考察的是类加载器实例化时进行的操作步骤（加载–&gt;连接-&gt;初始化） 父类静态代变量、父类静态代码块、子类静态变量、子类静态代码块、父类非静态变量（父类实例成员变量）、父类构造函数、有没有有顺序的 Map 实现类， 如果有， 他们是怎么保证有序的。TreeMap和LinkedHashMap是有序的（TreeMap默认升序，LinkedHashMap则记录了插入顺序子类非静态变量（子类实例成员变量）、子类构造函数。 3.有没有有顺序的Map实现类,如果有,他们是怎么保证有序的? TreeMap和LinkedHashMap是有序的（TreeMap默认升序， LinkedHashMap则记录了插入顺序) 4.简单说下HashMap的Put()方法 5.抽象类和接口的区别，类可以继承多个类么，接口可以继承多个接口么,类可以实现多个接口么？ 抽象类和接口都不能直接实例化，如果要实例化，抽象类变量必须指向实现所有抽象方法的子类对象，接口变量必须指向实现所有接口方法的类对象。 抽象类要被子类继承，接口要被类实现。 接口只能做方法申明，抽象类中可以做方法申明，也可以做方法实现 接口里定义的变量只能是公共的静态的常量，抽象类中的变量是普通变量。 抽象类里的抽象方法必须全部被子类所实现，如果子类不能全部实现父类抽象方法，那么该子类只能是抽象类。同样，一个实现接口的时候，如不能全部实现接口方法，那么该类也只能为抽象类。 抽象方法只能申明，不能实现。abstract void abc();不能写成abstract void abc(){}。 抽象类里可以没有抽象方法 如果一个类里有抽象方法，那么这个类只能是抽象类 抽象方法要被实现，所以不能是静态的，也不能是私有的。 接口可继承接口，并可多继承接口，但类只能单根继承。 6.继承和聚合的区别在哪 继承指的是一个类（称为子类、子接口）继承另外的一个类（称为父类、父接口）的功能，并可以增加它自己的新功能的能力，继承是类与类或者接口与接口之间最常见的关系；在Java中此类关系通过关键字extends明确标识，在设计时一般没有争议性； 聚合是关联关系的一种特例，他体现的是整体与部分、拥有的关系，即has-a的关系，此时整体与部分之间是可分离的，他们可以具有各自的生命周期，部分可以属于多个整体对象，也可以为多个整体对象共享；比如计算机与CPU、公司与员工的关系等；表现在代码层面，和关联关系是一致的，只能从语义级别来区分；]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手动删除数据库的dbf文件导致错误]]></title>
    <url>%2F2019%2F08%2F28%2F%E6%89%8B%E5%8A%A8%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84dbf%E6%96%87%E4%BB%B6%E5%AF%BC%E8%87%B4%E9%94%99%E8%AF%AF%2F</url>
    <content type="text"><![CDATA[问题：清理服务器时，误删除了数据库的dbf文件，且未备份，导致今天在启动数据库时无法启动，经网上查找资料和参考，整理方法如下：操作步骤：]]></content>
      <categories>
        <category>Oracle</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新建工程并关联提交到Github]]></title>
    <url>%2F2019%2F08%2F26%2F%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B%E5%B9%B6%E5%85%B3%E8%81%94%E6%8F%90%E4%BA%A4%E5%88%B0Github%2F</url>
    <content type="text"><![CDATA[cd进入你放项目文件的地址，我的地址在D:\WORK\项目程序 输入git init 这个意思是在当前项目的目录中生成本地的git管理（会发现在当前目录下多了一个.git文件夹） 输入git add 这个是将项目上所有的文件添加到仓库中的意思，如果想添加某个特定的文件，只需把.换成这个特定的文件名即可。 输入git commit -m &quot;first commit&quot;表示你对这次提交的注释，双引号里面的内容可以根据个人的需要改。 输入git remote add origin https://自己的gihub仓库url地址,将本地的仓库关联到github上,这里本人输入的是git remote add origin https://github.com/AugusZhu/JavaTools.git 输入git push -u origin master，这是把代码上传到github远程仓库 踩坑注意 若第五步报错如下 To https://github.com/AugusZhu/JavaTools.git ! [rejected] master -&gt; master (fetch first) error: failed to push some refs to ‘https://github.com/AugusZhu/JavaTools.git&#39; 原因：本地没有update到最新版本的项目（git上有README.md文件没下载下来） 解决办法：git pull --rebase origin master可以看到，此时已经把github上最新的文件下载下来了, 接着再 git push origin master]]></content>
      <categories>
        <category>Github</category>
      </categories>
      <tags>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[weblogic12c集群搭建]]></title>
    <url>%2F2019%2F08%2F24%2Fweblogic12c%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[weblogic12c集群搭建环境配置 服务器名 监听地址 监听端口 备注 AdminServer (管理) 10.40.128.182 7001 管理服务器 proxy-server 10.40.128.182 8080 代理服务器 Server-0 10.40.128.182 9002 受管服务器 Server-1 10.40.128.183 9002 受管服务器 启动管理服务器进去创建的域所在目录，执行nohup ./bin/startWeblogic.sh &amp; 进入控制台http://10.40.128.182:7001/console 配置服务器 点击环境-&gt;服务器-&gt;新建 输入服务器地名Server-0，主机IP 10.40.128.182，端口号 9002 集群不用选择 同理，配置好Server-1，proxy-server ##创建集群 点击环境-&gt;集群-&gt;新建-&gt;集群 选择多点传送，不用管多点传送地址 点击确定 ##创建计算机 创建计算机以配置节点管理器 点击环境-&gt;计算机-&gt;新建，输入计算机名称，操作系统类型 将连接类型设为普通，监听地址改为10.40.128.182 点击确定 ##配置受管服务器的计算机和集群 点击环境-&gt;服务器，点击服务server-0 配置计算机和集群信息 同理配置Server-1，proxy-server 但是procy-server不需要配置集群。 ##启动节点管理器进入创建的域所在的目录，执行nohup ./bin/startNodeManager.sh &gt; nodeManager.log 2&gt;&amp;1 &amp; ##配置代理服务器进入weblogic目录下 ./wlserver/common/bin/执行./config.sh选择更新现有配置。创建代理服务器，服务器选择proxy-server。进入所在域的目录，进入./apps/OracleProxy4_Cluster-0_proxy-server/WEB-INF,修改weblogic.xml。修改如图参数为项目的上下文。然后部署更新代理服务器项目。 ##启动服务器复制10.40.128.182上域所在目录，到10.40.128.183下。启动183的weblogic。在182执行 ./bin/startManagedWeblogic.sh proxy-server http://10.40.128.182:7001./bin/startManagedWeblogic.sh Server-0 http://10.40.128.182:7001在183执行./bin/startManagedWeblogic.sh Server-1 http://10.30.128.182:7001可在http://10.40.128.182:7001/console服务器上看到执行成功。(/images/pasted-12.png) ##配置session复制在项目的WEF-INF文件夹下新增weblogic.xml: 123456789101112131415&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE weblogic-web-app PUBLIC "-//BEA Systems, Inc.//DTD Web Application 8.1//EN" "http://www.bea.com/servers/wls810/dtd/weblogic810-web-jar.dtd"&gt;&lt;weblogic-web-app&gt; &lt;session-descriptor&gt; &lt;session-param&gt; &lt;param-name&gt;CookieName&lt;/param-name&gt; &lt;param-value&gt;JSESSIONID1&lt;/param-value&gt; &lt;/session-param&gt; &lt;session-param&gt; &lt;param-name&gt;PersistentStoreType&lt;/param-name&gt; &lt;param-value&gt;replicated_if_clustered&lt;/param-value&gt; &lt;/session-param&gt; &lt;/session-descriptor&gt;&lt;/weblogic-web-app&gt; ##完成部署项目，完成后。访问http://10.40.128.182:8080/core ###踩坑 后台免密启动受管服务器进入sercers文件夹下需要免密启动的服务器文件夹，进入security目录，创建boot.properties。格式为： 12username=weblogicpassword=weblogic 首次启动后自动会被加密 报错信息如下：启动时未能连接到管理服务器。可能是节点管理器未能启动的原因。需要先启动管理服务器上的节点管理器。nohup ./startNodeManager.sh &gt; nodeManager.log 2&gt;&amp;1 &amp;0v0 项目启动后发现点击登录后仍然跳转到登录页面不报错，怀疑是session复制的问题。经过研究发现是由于2台受管服务器连接的不是同一个redis。修改config.properties中redis.ip为其中一台服务器的ip。2台服务器的redis最好做一个主备。 websocket在weblogic服务器下无法使用，sockJs会自动切换到xhr-streaming协议。 项目启动后，登陆页面后跳转报错，提示服务器资源无法访问。由于weblogic在访问/时会自动跳转到/index.html，因此需要在页面注册注册index.html。]]></content>
      <categories>
        <category>weblogic</category>
      </categories>
      <tags>
        <tag>weblogic</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle修复系统包损坏]]></title>
    <url>%2F2019%2F08%2F21%2FOracle%E4%BF%AE%E5%A4%8D%E7%B3%BB%E7%BB%9F%E5%8C%85%E6%8D%9F%E5%9D%8F%2F</url>
    <content type="text"><![CDATA[问题：项目上遇到了dbms_aq包损坏的情况，导致高级队列无法正常使用，oracle定时任务也无法启动。 解决办法：oracle加密系统包损坏后无法通过单独编译包来恢复，需要使用内置脚本catproc.sql重新编译整个oracle的系统工具包。操作方法： 1 在oracle服务器上找到catproc.sql文件 2 sqlplus下执行此脚本，执行时间可能较久 3 修复完成后有些过程可能需要重新授权]]></content>
      <categories>
        <category>Oracle</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[本博客搭建指南]]></title>
    <url>%2F2019%2F08%2F20%2F%E6%9C%AC%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[构架1Hexo + Github Pages + Next 参考网址: 链接]]></content>
  </entry>
</search>
